{
  "_args": [
    [
      {
        "raw": "jest-each@^24.0.0",
        "scope": null,
        "escapedName": "jest-each",
        "name": "jest-each",
        "rawSpec": "^24.0.0",
        "spec": ">=24.0.0 <25.0.0",
        "type": "range"
      },
      "C:\\Users\\User\\helloworld\\node_modules\\jest-jasmine2"
    ]
  ],
  "_from": "jest-each@^24.0.0",
  "_hasShrinkwrap": false,
  "_id": "jest-each@24.0.0",
  "_location": "/jest-each",
  "_nodeVersion": "8.11.3",
  "_npmOperationalInternal": {
    "host": "s3://npm-registry-packages",
    "tmp": "tmp/jest-each_24.0.0_1548428711399_0.9519857301984389"
  },
  "_npmUser": {
    "name": "rubennorte",
    "email": "rubennorte@gmail.com"
  },
  "_npmVersion": "lerna/3.10.5/node@v8.11.3+x64 (darwin)",
  "_phantomChildren": {
    "color-convert": "1.9.3",
    "escape-string-regexp": "1.0.5",
    "has-flag": "3.0.0"
  },
  "_requested": {
    "raw": "jest-each@^24.0.0",
    "scope": null,
    "escapedName": "jest-each",
    "name": "jest-each",
    "rawSpec": "^24.0.0",
    "spec": ">=24.0.0 <25.0.0",
    "type": "range"
  },
  "_requiredBy": [
    "/jest-jasmine2"
  ],
  "_resolved": "https://registry.npmjs.org/jest-each/-/jest-each-24.0.0.tgz",
  "_shasum": "10987a06b21c7ffbfb7706c89d24c52ed864be55",
  "_shrinkwrap": null,
  "_spec": "jest-each@^24.0.0",
  "_where": "C:\\Users\\User\\helloworld\\node_modules\\jest-jasmine2",
  "author": {
    "name": "Matt Phillips",
    "url": "mattphillips"
  },
  "bugs": {
    "url": "https://github.com/facebook/jest/issues"
  },
  "dependencies": {
    "chalk": "^2.0.1",
    "jest-get-type": "^24.0.0",
    "jest-util": "^24.0.0",
    "pretty-format": "^24.0.0"
  },
  "description": "Parameterised tests for Jest",
  "devDependencies": {},
  "directories": {},
  "dist": {
    "integrity": "sha512-gFcbY4Cu55yxExXMkjrnLXov3bWO3dbPAW7HXb31h/DNWdNc/6X8MtxGff8nh3/MjkF9DpVqnj0KsPKuPK0cpA==",
    "shasum": "10987a06b21c7ffbfb7706c89d24c52ed864be55",
    "tarball": "https://registry.npmjs.org/jest-each/-/jest-each-24.0.0.tgz",
    "fileCount": 5,
    "unpackedSize": 22030,
    "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJcSyWoCRA9TVsSAnZWagAA5SwP/iHWe8HGdmqwX2om8Af5\nDq+1/hvZyEGOZdu7lj6wONSlqQeleX1m0CsWToglegrAZZM/WxgJfMsuNa5a\nTEHZcmma4heCxBO/j0q+oj7Qjhx6/R9nO8ST1PXaz0GUjcu+QhCFtfjzjofM\nCCIipZzszn7JEYTYiWLpGOPlt87WhdEIFx0lBHPf8FAlycZ+/M5tNMEiziPg\nnvHs2qrXq3chOtZDkuSsHRP2EyjpqVtq/euladhKxk2caSfiM37Z4oMz8JsG\nlcza/8jiDt9GaEEW6c2EXNO1zWDfi245cvKDseZWTDu586Kv60y7Bgw/LA3D\nbaZJfWdJAwqck3LDp8FYkhBdkd3L1Y6P5OFwtw08OmeY33NusZ5JXfc/84Q/\n0of37yt0gOvXAfuF2c+jMHzU64qGZBCso5Q2FedyowmlDGwpjZ7NnHYqRgLP\nXTDCys1cMARBqGNu9h6PyGI3XKEKTX0KGO+62VihPWMTT0UVluxCpAxegv87\ntmwyrG83m0ikzbyXi4AdN3Ysc0JUf0nSLxzOItp43iAWW2xcqpU9oDMWao2A\nR0sZTXNXqWdtVh6j+zi3CVkCQdMI6IRuTkfP6QCltnI99LYRAxAH2rbQI7Ba\nzO5BjoeGBgvePhX8NAmKCLogzfxPZABb6zOtxOJZPfAY9jGfH0xXq9xo6m08\nwjp6\r\n=KVWr\r\n-----END PGP SIGNATURE-----\r\n"
  },
  "engines": {
    "node": ">= 6"
  },
  "gitHead": "634e5a54f46b2a62d1dc81a170562e6f4e55ad60",
  "homepage": "https://github.com/facebook/jest#readme",
  "keywords": [
    "jest",
    "parameterised",
    "test",
    "each"
  ],
  "license": "MIT",
  "main": "build/index.js",
  "maintainers": [
    {
      "name": "mattphillips",
      "email": "matt@mattphillips.io"
    },
    {
      "name": "rubennorte",
      "email": "rubennorte@gmail.com"
    }
  ],
  "name": "jest-each",
  "optionalDependencies": {},
  "readme": "<div align=\"center\">\n  <h1>jest-each</h1>\n  Jest Parameterised Testing\n</div>\n\n<hr />\n\n[![version](https://img.shields.io/npm/v/jest-each.svg?style=flat-square)](https://www.npmjs.com/package/jest-each) [![downloads](https://img.shields.io/npm/dm/jest-each.svg?style=flat-square)](http://npm-stat.com/charts.html?package=jest-each&from=2017-03-21) [![MIT License](https://img.shields.io/npm/l/jest-each.svg?style=flat-square)](https://github.com/facebook/jest/blob/master/LICENSE)\n\nA parameterised testing library for [Jest](https://jestjs.io/) inspired by [mocha-each](https://github.com/ryym/mocha-each).\n\njest-each allows you to provide multiple arguments to your `test`/`describe` which results in the test/suite being run once per row of parameters.\n\n## Features\n\n- `.test` to runs multiple tests with parameterised data\n  - Also under the alias: `.it`\n- `.test.only` to only run the parameterised tests\n  - Also under the aliases: `.it.only` or `.fit`\n- `.test.skip` to skip the parameterised tests\n  - Also under the aliases: `.it.skip` or `.xit` or `.xtest`\n- `.describe` to runs test suites with parameterised data\n- `.describe.only` to only run the parameterised suite of tests\n  - Also under the aliases: `.fdescribe`\n- `.describe.skip` to skip the parameterised suite of tests\n  - Also under the aliases: `.xdescribe`\n- Asynchronous tests with `done`\n- Unique test titles with [`printf` formatting](https://nodejs.org/api/util.html#util_util_format_format_args):\n  - `%p` - [pretty-format](https://www.npmjs.com/package/pretty-format).\n  - `%s`- String.\n  - `%d`- Number.\n  - `%i` - Integer.\n  - `%f` - Floating point value.\n  - `%j` - JSON.\n  - `%o` - Object.\n  - `%#` - Index of the test case.\n  - `%%` - single percent sign ('%'). This does not consume an argument.\n- ðŸ–– Spock like data tables with [Tagged Template Literals](#tagged-template-literal-of-rows)\n\n---\n\n- [Demo](#demo)\n- [Installation](#installation)\n- [Importing](#importing)\n- APIs\n  - [Array of Rows](#array-of-rows)\n    - [Usage](#usage)\n  - [Tagged Template Literal of rows](#tagged-template-literal-of-rows)\n    - [Usage](#usage-1)\n\n## Demo\n\n#### Tests without jest-each\n\n![Current jest tests](assets/default-demo.gif)\n\n#### Tests can be re-written with jest-each to:\n\n**`.test`**\n\n![Current jest tests](assets/test-demo.gif)\n\n**`.test` with Tagged Template Literals**\n\n![Current jest tests](assets/tagged-template-literal.gif)\n\n**`.describe`**\n\n![Current jest tests](assets/describe-demo.gif)\n\n## Installation\n\n`npm i --save-dev jest-each`\n\n`yarn add -D jest-each`\n\n## Importing\n\njest-each is a default export so it can be imported with whatever name you like.\n\n```js\n// es6\nimport each from 'jest-each';\n```\n\n```js\n// es5\nconst each = require('jest-each');\n```\n\n## Array of rows\n\n### API\n\n#### `each([parameters]).test(name, testFn)`\n\n##### `each`:\n\n- parameters: `Array` of Arrays with the arguments that are passed into the `testFn` for each row\n  - _Note_ If you pass in a 1D array of primitives, internally it will be mapped to a table i.e. `[1, 2, 3] -> [[1], [2], [3]]`\n\n##### `.test`:\n\n- name: `String` the title of the `test`.\n  - Generate unique test titles by positionally injecting parameters with [`printf` formatting](https://nodejs.org/api/util.html#util_util_format_format_args):\n    - `%p` - [pretty-format](https://www.npmjs.com/package/pretty-format).\n    - `%s`- String.\n    - `%d`- Number.\n    - `%i` - Integer.\n    - `%f` - Floating point value.\n    - `%j` - JSON.\n    - `%o` - Object.\n    - `%#` - Index of the test case.\n    - `%%` - single percent sign ('%'). This does not consume an argument.\n- testFn: `Function` the test logic, this is the function that will receive the parameters of each row as function arguments\n\n#### `each([parameters]).describe(name, suiteFn)`\n\n##### `each`:\n\n- parameters: `Array` of Arrays with the arguments that are passed into the `suiteFn` for each row\n  - _Note_ If you pass in a 1D array of primitives, internally it will be mapped to a table i.e. `[1, 2, 3] -> [[1], [2], [3]]`\n\n##### `.describe`:\n\n- name: `String` the title of the `describe`\n  - Generate unique test titles by positionally injecting parameters with [`printf` formatting](https://nodejs.org/api/util.html#util_util_format_format_args):\n    - `%p` - [pretty-format](https://www.npmjs.com/package/pretty-format).\n    - `%s`- String.\n    - `%d`- Number.\n    - `%i` - Integer.\n    - `%f` - Floating point value.\n    - `%j` - JSON.\n    - `%o` - Object.\n    - `%#` - Index of the test case.\n    - `%%` - single percent sign ('%'). This does not consume an argument.\n- suiteFn: `Function` the suite of `test`/`it`s to be ran, this is the function that will receive the parameters in each row as function arguments\n\n### Usage\n\n#### `.test(name, fn)`\n\nAlias: `.it(name, fn)`\n\n```js\neach([[1, 1, 2], [1, 2, 3], [2, 1, 3]]).test(\n  'returns the result of adding %d to %d',\n  (a, b, expected) => {\n    expect(a + b).toBe(expected);\n  },\n);\n```\n\n#### `.test.only(name, fn)`\n\nAliases: `.it.only(name, fn)` or `.fit(name, fn)`\n\n```js\neach([[1, 1, 2], [1, 2, 3], [2, 1, 3]]).test.only(\n  'returns the result of adding %d to %d',\n  (a, b, expected) => {\n    expect(a + b).toBe(expected);\n  },\n);\n```\n\n#### `.test.skip(name, fn)`\n\nAliases: `.it.skip(name, fn)` or `.xit(name, fn)` or `.xtest(name, fn)`\n\n```js\neach([[1, 1, 2][(1, 2, 3)], [2, 1, 3]]).test.skip(\n  'returns the result of adding %d to %d',\n  (a, b, expected) => {\n    expect(a + b).toBe(expected);\n  },\n);\n```\n\n#### Asynchronous `.test(name, fn(done))`\n\nAlias: `.it(name, fn(done))`\n\n```js\neach([['hello'], ['mr'], ['spy']]).test(\n  'gives 007 secret message: %s',\n  (str, done) => {\n    const asynchronousSpy = message => {\n      expect(message).toBe(str);\n      done();\n    };\n    callSomeAsynchronousFunction(asynchronousSpy)(str);\n  },\n);\n```\n\n#### `.describe(name, fn)`\n\n```js\neach([[1, 1, 2], [1, 2, 3], [2, 1, 3]]).describe(\n  '.add(%d, %d)',\n  (a, b, expected) => {\n    test(`returns ${expected}`, () => {\n      expect(a + b).toBe(expected);\n    });\n\n    test('does not mutate first arg', () => {\n      a + b;\n      expect(a).toBe(a);\n    });\n\n    test('does not mutate second arg', () => {\n      a + b;\n      expect(b).toBe(b);\n    });\n  },\n);\n```\n\n#### `.describe.only(name, fn)`\n\nAliases: `.fdescribe(name, fn)`\n\n```js\neach([[1, 1, 2], [1, 2, 3], [2, 1, 3]]).describe.only(\n  '.add(%d, %d)',\n  (a, b, expected) => {\n    test(`returns ${expected}`, () => {\n      expect(a + b).toBe(expected);\n    });\n  },\n);\n```\n\n#### `.describe.skip(name, fn)`\n\nAliases: `.xdescribe(name, fn)`\n\n```js\neach([[1, 1, 2], [1, 2, 3], [2, 1, 3]]).describe.skip(\n  '.add(%d, %d)',\n  (a, b, expected) => {\n    test(`returns ${expected}`, () => {\n      expect(a + b).toBe(expected);\n    });\n  },\n);\n```\n\n---\n\n## Tagged Template Literal of rows\n\n### API\n\n#### `each[tagged template].test(name, suiteFn)`\n\n```js\neach`\n  a    | b    | expected\n  ${1} | ${1} | ${2}\n  ${1} | ${2} | ${3}\n  ${2} | ${1} | ${3}\n`.test('returns $expected when adding $a to $b', ({a, b, expected}) => {\n  expect(a + b).toBe(expected);\n});\n```\n\n##### `each` takes a tagged template string with:\n\n- First row of variable name column headings seperated with `|`\n- One or more subsequent rows of data supplied as template literal expressions using `${value}` syntax.\n\n##### `.test`:\n\n- name: `String` the title of the `test`, use `$variable` in the name string to inject test values into the test title from the tagged template expressions\n  - To inject nested object values use you can supply a keyPath i.e. `$variable.path.to.value`\n- testFn: `Function` the test logic, this is the function that will receive the parameters of each row as function arguments\n\n#### `each[tagged template].describe(name, suiteFn)`\n\n```js\neach`\n  a    | b    | expected\n  ${1} | ${1} | ${2}\n  ${1} | ${2} | ${3}\n  ${2} | ${1} | ${3}\n`.describe('$a + $b', ({a, b, expected}) => {\n  test(`returns ${expected}`, () => {\n    expect(a + b).toBe(expected);\n  });\n\n  test('does not mutate first arg', () => {\n    a + b;\n    expect(a).toBe(a);\n  });\n\n  test('does not mutate second arg', () => {\n    a + b;\n    expect(b).toBe(b);\n  });\n});\n```\n\n##### `each` takes a tagged template string with:\n\n- First row of variable name column headings seperated with `|`\n- One or more subsequent rows of data supplied as template literal expressions using `${value}` syntax.\n\n##### `.describe`:\n\n- name: `String` the title of the `test`, use `$variable` in the name string to inject test values into the test title from the tagged template expressions\n  - To inject nested object values use you can supply a keyPath i.e. `$variable.path.to.value`\n- suiteFn: `Function` the suite of `test`/`it`s to be ran, this is the function that will receive the parameters in each row as function arguments\n\n### Usage\n\n#### `.test(name, fn)`\n\nAlias: `.it(name, fn)`\n\n```js\neach`\n  a    | b    | expected\n  ${1} | ${1} | ${2}\n  ${1} | ${2} | ${3}\n  ${2} | ${1} | ${3}\n`.test('returns $expected when adding $a to $b', ({a, b, expected}) => {\n  expect(a + b).toBe(expected);\n});\n```\n\n#### `.test.only(name, fn)`\n\nAliases: `.it.only(name, fn)` or `.fit(name, fn)`\n\n```js\neach`\n  a    | b    | expected\n  ${1} | ${1} | ${2}\n  ${1} | ${2} | ${3}\n  ${2} | ${1} | ${3}\n`.test.only('returns $expected when adding $a to $b', ({a, b, expected}) => {\n  expect(a + b).toBe(expected);\n});\n```\n\n#### `.test.skip(name, fn)`\n\nAliases: `.it.skip(name, fn)` or `.xit(name, fn)` or `.xtest(name, fn)`\n\n```js\neach`\n  a    | b    | expected\n  ${1} | ${1} | ${2}\n  ${1} | ${2} | ${3}\n  ${2} | ${1} | ${3}\n`.test.skip('returns $expected when adding $a to $b', ({a, b, expected}) => {\n  expect(a + b).toBe(expected);\n});\n```\n\n#### Asynchronous `.test(name, fn(done))`\n\nAlias: `.it(name, fn(done))`\n\n```js\neach`\n  str\n  ${'hello'}\n  ${'mr'}\n  ${'spy'}\n`.test('gives 007 secret message: $str', ({str}, done) => {\n  const asynchronousSpy = message => {\n    expect(message).toBe(str);\n    done();\n  };\n  callSomeAsynchronousFunction(asynchronousSpy)(str);\n});\n```\n\n#### `.describe(name, fn)`\n\n```js\neach`\n  a    | b    | expected\n  ${1} | ${1} | ${2}\n  ${1} | ${2} | ${3}\n  ${2} | ${1} | ${3}\n`.describe('$a + $b', ({a, b, expected}) => {\n  test(`returns ${expected}`, () => {\n    expect(a + b).toBe(expected);\n  });\n\n  test('does not mutate first arg', () => {\n    a + b;\n    expect(a).toBe(a);\n  });\n\n  test('does not mutate second arg', () => {\n    a + b;\n    expect(b).toBe(b);\n  });\n});\n```\n\n#### `.describe.only(name, fn)`\n\nAliases: `.fdescribe(name, fn)`\n\n```js\neach`\n  a    | b    | expected\n  ${1} | ${1} | ${2}\n  ${1} | ${2} | ${3}\n  ${2} | ${1} | ${3}\n`.describe.only('$a + $b', ({a, b, expected}) => {\n  test(`returns ${expected}`, () => {\n    expect(a + b).toBe(expected);\n  });\n});\n```\n\n#### `.describe.skip(name, fn)`\n\nAliases: `.xdescribe(name, fn)`\n\n```js\neach`\n  a    | b    | expected\n  ${1} | ${1} | ${2}\n  ${1} | ${2} | ${3}\n  ${2} | ${1} | ${3}\n`.describe.skip('$a + $b', ({a, b, expected}) => {\n  test(`returns ${expected}`, () => {\n    expect(a + b).toBe(expected);\n  });\n});\n```\n\n## License\n\nMIT\n",
  "readmeFilename": "README.md",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/facebook/jest.git",
    "directory": "packages/jest-each"
  },
  "version": "24.0.0"
}
